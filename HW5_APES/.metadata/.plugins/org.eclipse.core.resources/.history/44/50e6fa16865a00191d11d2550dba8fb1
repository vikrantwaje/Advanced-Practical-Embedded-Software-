/***************************************************************************************
 * @file mythreads.c
 * @brief This file is to be used for defining the callback function associated with two threads
 * @author Vikrant Waje
 * @date April 7, 2019
 *
 *****************************************************************************************/

//***********************************************************************************
//                                  Include files
//***********************************************************************************
#include"main.h"
//***********************************************************************************
//                                  Global variables
//***********************************************************************************
uint32_t g_ui32LEDDelay;
xSemaphoreHandle logger_mutex;  //Mutex to protect simultaneous access to Queue
QueueHandle_t xLogger_Queue; //Queue through which messages are passed
log_msg_t logger_message;   //Structure to store logger messages
log_msg_t receive_message;  // Structure to receive messages
TaskHandle_t Alert_taskhandler;
SemaphoreHandle_t xSemaphore_led;
SemaphoreHandle_t xSemaphore_temperature;
//***********************************************************************************
//                                 Function implementation
//***********************************************************************************
/*------------------------------------------------------------------------------------------------------------------------------------*/
/*
 @brief: Callback function for Led Task


 @param: None
 @param:None

 @return: None
 */
/*-----------------------------------------------------------------------------------------------------------------------------*/
void LedTask(void *pvParameters)
{

    while (1)
    {

        xSemaphoreTake(xSemaphore_led, (TickType_t ) portMAX_DELAY);

        led_on(D1_LED_PORT, D1_LED_PIN, D1_ON);
        led_on(D2_LED_PORT, D2_LED_PIN, D2_ON);

        vTaskDelay(pdMS_TO_TICKS(20));

        led_off(D1_LED_PORT, D1_LED_PIN, OFF);
        led_off(D2_LED_PORT, D2_LED_PIN, OFF);

        strcpy(logger_message.custom_message, "Led Task");
        logger_message.thread_specific_data = 1;
        logger_message.timestamp = xTaskGetTickCount();

        if(xSemaphoreTake( logger_mutex, ( TickType_t )20 ) == pdTRUE) ;
             {
              xQueueSend(xLogger_Queue, (void * ) &logger_message,
                     (TickType_t )portMAX_DELAY);
              xSemaphoreGive(logger_mutex);

             }


    }
}

/*------------------------------------------------------------------------------------------------------------------------------------*/
/*
 @brief: Callback function for Temperature Task


 @param: None
 @param:None

 @return: None
 */
/*-----------------------------------------------------------------------------------------------------------------------------*/
void TemperatureTask(void *pvParameters)
{
    i2c_status_t read_status;
    double *temperature_value = NULL;
    uint8_t float_val;
    temperature_value = malloc(sizeof(double));
    while (1)
    {

        // UARTprintf("\n\nValue = %u%c%u\n", (uint32_t) *temperature_value,'.',float_val);

        xSemaphoreTake(xSemaphore_temperature, (TickType_t ) portMAX_DELAY);


        //i2c_read_two_byte(TEMP_SENSOR_I2C_ADDRESS,TEMPERATURE_REG, temp_data);
        read_status = get_temperature(REQUEST_CELSIUS, temperature_value);
        if (*temperature_value >= 28)
        {
            xTaskNotifyGive(Alert_taskhandler);

        }
        float_val = (100 * (*temperature_value))
                - (100 * (uint32_t) (*temperature_value));
        if (read_status != READ_SUCCESS)
        {
            // UARTprintf("\n\nReading from temperature sensor failed!\n");

        }

        strcpy(logger_message.custom_message, "Temp Task");
        logger_message.thread_specific_data = *temperature_value;
        logger_message.timestamp = xTaskGetTickCount();

        if(xSemaphoreTake( logger_mutex, ( TickType_t )20 ) == pdTRUE) ;
        {
         xQueueSend(xLogger_Queue, (void * ) &logger_message,
                (TickType_t )portMAX_DELAY);
         xSemaphoreGive(logger_mutex);

        }


        //vTaskDelay(pdMS_TO_TICKS(500));

        //}
    }

}

/*------------------------------------------------------------------------------------------------------------------------------------*/
/*
 @brief: Callback function for Logger Task


 @param: None
 @param:None

 @return: None
 */
/*-----------------------------------------------------------------------------------------------------------------------------*/
void LoggerTask(void *pvParameters)
{
    while (1)
    {
        if (xQueueReceive(xLogger_Queue, &(receive_message), (TickType_t ) 1))
        {

            UARTprintf(
                    "\n\rreceive message = %s, sensor data = %u, Timestamp =%u ",
                    receive_message.custom_message,
                    (uint32_t) receive_message.thread_specific_data,
                    receive_message.timestamp);
        }

    }

}

/*------------------------------------------------------------------------------------------------------------------------------------*/
/*
 @brief: Callback function for Alert Task
 @param: None
 @param:None

 @return: None
 */
/*-----------------------------------------------------------------------------------------------------------------------------*/
void AlertTask(void *pvParameters)
{
    while (1)
    {

        ulTaskNotifyTake( pdTRUE, portMAX_DELAY);


        strcpy(logger_message.custom_message, "THRESHOLD_CROSSED");
        logger_message.thread_specific_data = 0;
        logger_message.timestamp = xTaskGetTickCount();
        if(xSemaphoreTake( logger_mutex, ( TickType_t )20 ) == pdTRUE) ;
             {
              xQueueSend(xLogger_Queue, (void * ) &logger_message,
                     (TickType_t )portMAX_DELAY);
              xSemaphoreGive(logger_mutex);

             }

    }

}
