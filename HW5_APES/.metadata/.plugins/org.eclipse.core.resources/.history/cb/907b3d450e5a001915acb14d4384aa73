/***************************************************************************************
 * @file myi2c.c
 * @brief This file is to be used for initialization and data transfer function for I2C module.
 * @author Vikrant Waje
 * @date April 7, 2019
 *@Reference: http://www.ti.com/lit/an/spma073/spma073.pdf
 *****************************************************************************************/

//***********************************************************************************
//                                  Include files
//***********************************************************************************
#include "myi2c.h"

//***********************************************************************************
//                                  Global variables
//***********************************************************************************
uint32_t sys_clock;

//***********************************************************************************
//                                 Function implementation
//***********************************************************************************
/*------------------------------------------------------------------------------------------------------------------------------------*/
/*
 @brief: Setup the I2C peripheral.


 @param: None
 @param:None

 @return: None
 */
/*-----------------------------------------------------------------------------------------------------------------------------*/
void i2c_init(void)
{

    //
    // Stop the Clock, Reset and Enable I2C Module
    // in Master Function
    //
    SysCtlPeripheralDisable(SYSCTL_PERIPH_I2C2);
    SysCtlPeripheralReset(SYSCTL_PERIPH_I2C2);
    SysCtlPeripheralEnable(SYSCTL_PERIPH_I2C2);
    //
    // Wait for the Peripheral to be ready for programming
    //
    while (!SysCtlPeripheralReady(SYSCTL_PERIPH_I2C2))
        ;
    //
    // Initialize and Configure the Master Module
    //
    I2CMasterInitExpClk(I2C2_BASE, sys_clock, false);

}

/*------------------------------------------------------------------------------------------------------------------------------------*/
/*
 @brief: Read from I2C.


 @param: reg address: Address from which data is to be read
 @param: data: Pointer to data in which data is to be stored

 @return: i2c_status_t: Status of I2C operation
 */
/*-----------------------------------------------------------------------------------------------------------------------------*/
i2c_status_t i2c_read_two_byte(uint8_t slave_addr,uint8_t reg_addr, uint8_t *data)
{
    //Set the slave address and indicate write operation for transferring the register address
    I2CMasterSlaveAddrSet(I2C2_BASE, slave_addr, I2C_WRITE);
    // Send the register address
    I2CMasterDataPut(I2C2_BASE, reg_addr);
    //Indicate start condition
    I2CMasterControl(I2C2_BASE, I2C_MASTER_CMD_BURST_SEND_START);
    MAP_SysCtlDelay(100);
    while(I2CMasterBusy(I2C2_BASE));
    //Set the slave address and generate repeated start condition for reading from the bus
    I2CMasterSlaveAddrSet(I2C2_BASE, slave_addr, I2C_READ);
    I2CMasterControl(I2C2_BASE, I2C_MASTER_CMD_BURST_RECEIVE_START);
    MAP_SysCtlDelay(300);
    while (I2CMasterBusy(I2C2_BASE));
    //Get first byte from sensor
    *(data + 1) = I2CMasterDataGet(I2C2_BASE);
    I2CMasterControl(I2C2_BASE, I2C_MASTER_CMD_BURST_RECEIVE_FINISH);
    MAP_SysCtlDelay(300);
    while (I2CMasterBusy(I2C2_BASE));
    //Get second byte from sensor
    *(data + 0) = I2CMasterDataGet(I2C2_BASE);

    return READ_SUCCESS;
}
/***********************************************************************************************
 * @brief Get temperature
 *
 * Read the value from temperature register
 *
 * @param NULL
 * @return double: Value of temperature
 *********************************************************************************************/

/*
i2c_status_t get_temperature(request_cmd_t request){



    //double result = 0;
    double multiplier =0;
    uint8_t *data = malloc(sizeof(uint8_t) * 2);
    if ( data == NULL )
    {
        return READ_REG_FAIL;
    }
    multiplier = 0.0625;
    int status = temperature_read_reg(TEMPERATURE_REG,data,ALL);
    if(status !=READ_REG_SUCCESS){

        perror("Reading configuration register failed");
        free( data );
        pthread_mutex_unlock(&i2c_mutex);
        return READ_TEMPERATURE_ERROR;
    }
    //printf("%x %x",*(data + 0),*(data +1));

    int32_t digitalTemp =0;

    // Bit 0 of second byte will always be 0 in 12-bit readings and 1 in 13-bit
    if(*(data + 0)&0x01)    // 13 bit mode
    {
        // Combine bytes to create a signed int
        digitalTemp = (*(data + 1) << 5) | (*(data + 0) >> 3);
        // Temperature data can be + or -, if it should be negative,
        // convert 13 bit to 16 bit and use the 2s compliment.
        if(digitalTemp > 0xFFF)
        {
            digitalTemp |= 0xE000;
        }
    }
    else    // 12 bit mode
    {
        // Combine bytes to create a signed int
        digitalTemp = (*(data + 1) << 4) | (*(data + 0) >> 4);
        // Temperature data can be + or -, if it should be negative,
        // convert 12 bit to 16 bit and use the 2s compliment.
        if(digitalTemp > 0x7FF)
        {
            digitalTemp |= 0xF000;
        }
    }
    // Convert digital reading to analog temperature (1-bit is equal to 0.0625 C)

    free(data);


    if ( request == REQUEST_KELVIN )
    {
        return(digitalTemp*multiplier + 273.15);
    }
    else if ( request == REQUEST_FAHRENHEIT )
    {
        return ((digitalTemp*multiplier * 9.0/5.0) + 32.0);
    }
    else
        return(digitalTemp*multiplier);
}
*/
